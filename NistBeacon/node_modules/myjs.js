
			
function getNextRecord(fs, time, outFileName) {
	beacon.nextRecord(time, function (err, res) {
		  // prints the beacon value closest to epochTime in 128 hex characters (or 64 chars)
		  
				if (err) {
					return console.error(err);;
				}
		  
				var hex = res, // ASCII HEX: 37="7", 57="W", 71="q"
					bytes = [];
				var str = '';
				for(var i = 0; i < hex.length - 1; i += 2){
					var ch = parseInt(hex.substr(i, 2), 16);
					for (var jj = 0; jj < 8; jj++) {
						if ((ch & (1 << jj)) == 0)
							bytes.push('0'.charCodeAt(0));
						else
							bytes.push('1'.charCodeAt(0));
					}
					//bytes.push(ch);
				}

				str = String.fromCharCode.apply(String, bytes);
				fs.appendFile(outFileName, str, function (err) {
					if (err) {
						return console.error(err);
					}
				});	  
			});
}

var fs = require("fs");
var beacon = require('nist-beacon');
var epochTime = //Math.floor(new Date() / 1000);
			//1510587836 	// - too long time
			//1410583756
			1410990436
			;
var k;
for (k = process.argv[3]; k <= process.argv[3]; k *= 2) {
	var outFileName = process.argv[2] + '\\input' + k + '.dat';
				//'\\input1024.dat';
	
	// fs.open(outFileName, 'w', function(err, fd) {
		// fs.close(fd, function(err) {});
	// });
	
	beacon.startChainRecord(epochTime, function(err, res) {});
	//process.argv[2] == count of Kbits, because one iteration == 64 bytes (512 bits)
	for (var j = 0; j < 2 * k; j++) {
		getNextRecord(fs, epochTime, outFileName);
		epochTime += 60;
	}
	
	fs.writeFile('epochTimeSave.dat', epochTime, function (err) {
		if (err) {
			return console.error(err);
		}
	});	  
}
//console.log('unix time = ' + epochTime);

